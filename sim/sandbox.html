<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.js"></script>
<script src="./javascript/THREE.OrbitControls.js"></script>
<script src="./javascript/OimoPhysics.js"></script>

<script type="module">
import World from "./javascript/world.js";
import OIMO_THREE from "./javascript/OIMO_THREE.js";
const D2R = Math.PI/180;

onload = function () {
  const sandbox = new SandBox();
  sandbox.start();
}

const meshNormalMaterial = new THREE.MeshNormalMaterial();
const redMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000, transparent: true, opacity: 0.8 });
const greenMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00, transparent: true, opacity: 1.0 });
const blueMaterial = new THREE.MeshLambertMaterial({ color: 0x0044ff, transparent: true, opacity: 0.7 });
const blue2Material = new THREE.MeshLambertMaterial({ color: 0x0055ff, transparent: true, opacity: 0.7 });
const blue3Material = new THREE.MeshLambertMaterial({ color: 0x0066ff, transparent: true, opacity: 0.7 });
const yellowMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
const orangeMaterial = new THREE.MeshLambertMaterial({ color: 0xff4400, transparent: true, opacity: 0.3 });
const grayMaterial = new THREE.MeshLambertMaterial({ color: 0x444444, transparent: true, opacity: 0.8 });
const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.5 });
const blackMaterial = new THREE.MeshLambertMaterial({ color: 0x000000, transparent: true, opacity: 0.5 });
const wireframeMaterial = new THREE.MeshPhongMaterial({ color: 0x00FFFF, wireframe: true });
const redWireframeMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, wireframe: true });
const yellowWireframeMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFF00, wireframe: true });
const matRed   = new THREE.MeshLambertMaterial({color: 0xff0000});
const matGreen = new THREE.MeshLambertMaterial({color: 0x00ff00});
const matBlue  = new THREE.MeshLambertMaterial({color: 0x0000ff});

const SandBox = function () {
  let world;
  let scene;
  let oimo_world;

  this.start = function (cb) {
    world = new World();
    world.setup();
    scene = world.scene;
    oimo_world = world.oimo_world;
    makeObjects();
    world.start((sim_t)=>{
    });
  };

  const makeObjects = function () {
    const make_ball = function (parent, local, r, color) {
      const group = new THREE.Group();
      const sp1 = new THREE.Mesh(new THREE.SphereGeometry(r, 32, 32), new THREE.MeshLambertMaterial({
        color: color
      }));
      sp1.position.set(local.x, local.y, local.z);
      sp1.oimo_shape_config = {
        //density: 0, // Kg/m^3
        //restitution: 1,
      }
      group.add(sp1);
      group.position.set(parent.x, parent.y, parent.z);

      OIMO_THREE.buildRigidBody(group);
      scene.add(group);
      oimo_world.addRigidBody(group.oimo_rigid_body);
      return group;
    }
    const b1 = make_ball({ "x": -100, "y": 100, "z":   0}, { "x": 0, "y": 0, "z":   0},  5, 0xff0000);
    const b2 = make_ball({ "x":  -50, "y": 100, "z": -10}, { "x": 0, "y": 0, "z":  10}, 10, 0x00ff00);
    const b3 = make_ball({ "x":    0, "y": 100, "z":  20}, { "x": 0, "y": 0, "z": -20}, 20, 0xffff00);
    const b4 = make_ball({ "x":  100, "y": 100, "z": -40}, { "x": 0, "y": 0, "z":  40}, 40, 0x0000ff);

    if ("T") {
      const x =   0;
      const z = -50;
      if (".") {
        const group = new THREE.Group();
        group.oimo_rigid_body_config = {
          type: OIMO.RigidBodyType.STATIC
        }

        group.position.x = x;
        group.position.z = z;

        const box1 = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 10), new THREE.MeshLambertMaterial({
          color: 0xffff00
        }));
        group.add(box1);

        OIMO_THREE.buildRigidBody(group);
        scene.add(group);
        oimo_world.addRigidBody(group.oimo_rigid_body);
      }

      const rotate = 22;
      if ("|") {
        const group = new THREE.Group();
        group.oimo_rigid_body_config = {
          //type: OIMO.RigidBodyType.STATIC
        }
        group.position.set(x, 0, z);
        group.rotation.y = rotate * Math.PI / 180;

        const size = 10;
        const box1 = new THREE.Mesh(new THREE.BoxGeometry(size, 50, size), new THREE.MeshLambertMaterial({
          color: 0xff4400
        }));
        box1.position.set(45, 25, 0);
        group.add(box1);

        OIMO_THREE.buildRigidBody(group);
        scene.add(group);
        oimo_world.addRigidBody(group.oimo_rigid_body);
      }
      if ("-") {
        const group = new THREE.Group();
        group.rotation.y = rotate * Math.PI / 180;

        const box1 = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), matRed);
        group.add(box1);

        const box2 = new THREE.Mesh(new THREE.BoxGeometry(90, 10, 10), matBlue);
        box2.position.set(50, 0, 0);
        group.add(box2);

        group.position.x = x;
        group.position.y = 70;
        group.position.z = z;

        OIMO_THREE.buildRigidBody(group);
        scene.add(group);
        oimo_world.addRigidBody(group.oimo_rigid_body);
      }
      if ("/") {
        const box1 = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 10), matBlue);
        box1.rotation.y = rotate * Math.PI / 180;

        const box2 = new THREE.Mesh(new THREE.BoxGeometry(40, 10, 10), matRed);
        box2.position.set(25, 0, 0);

        const box3 = new THREE.Mesh(new THREE.BoxGeometry(50, 10, 10), matGreen);
        box3.position.set(45, 0, 0);

        box1.add(box2);
        box2.add(box3);

        box1.position.x = x;
        box1.position.y = 90;
        box1.position.z = z;

        OIMO_THREE.buildRigidBody(box1);
        scene.add(box1);
        oimo_world.addRigidBody(box1.oimo_rigid_body);
      }
    }

    if ("RevoluteJoint") {
      const x = -200;
      const y = 120;
      const z = 0;
      const l = 30;

      const box1 = new THREE.Mesh(new THREE.BoxGeometry(30, 5, 5), matRed);
      box1.position.set(x, y, z);
      box1.oimo_rigid_body_config = {
        type: OIMO.RigidBodyType.STATIC
      }
      OIMO_THREE.buildRigidBody(box1);
      scene.add(box1);
      oimo_world.addRigidBody(box1.oimo_rigid_body);

      const box2 = new THREE.Mesh(new THREE.BoxGeometry(30, 5, l), matGreen);
      box2.oimo_shape_config = {
        //density: 0.1, // Kg/m^3
      }
      box2.position.set(x, y, z + l / 2);
      OIMO_THREE.buildRigidBody(box2);
      scene.add(box2);
      oimo_world.addRigidBody(box2.oimo_rigid_body);

      const box3 = new THREE.Mesh(new THREE.BoxGeometry(30, 5, l), matBlue);
      box3.oimo_shape_config = {
        //density: 0.1, // Kg/m^3
      }
      box3.position.set(x, y, z + l / 2 + l);
      OIMO_THREE.buildRigidBody(box3);
      scene.add(box3);
      oimo_world.addRigidBody(box3.oimo_rigid_body);

      if (1) {
        const worldAnchor = new OIMO.Vec3(box1.position.x / OIMO_THREE.SCALE, box1.position.y / OIMO_THREE.SCALE, box1.position.z / OIMO_THREE.SCALE);
        const worldAxis = new OIMO.Vec3(1, 0, 0);
        const c = new OIMO.RevoluteJointConfig();
        c.init(
          box1.oimo_rigid_body,
          box2.oimo_rigid_body,
          worldAnchor,
          worldAxis
        );
        //c.limitMotor.setLimits(-180 * Math.PI / 180, 180 * Math.PI / 180);
        //c.springDamper.setSpring(4, 1.0);
        //c.limitMotor.setLimits(-45 * D2R, 45 * D2R)
        c.limitMotor.setMotor(-45 * Math.PI / 180, 1.0);
        // const frequency    =  1000;
        // const dampingRatio =  1000;
        // c.springDamper.setSpring(frequency, dampingRatio);
        const j = new OIMO.RevoluteJoint(c);
        oimo_world.addJoint(j);
        // box1.animate = ()=>{
        //   const d = j.getAngle() / D2R;
        //   console.log("d=", d);
        // }
      }
      if (1) {
        const worldAnchor = new OIMO.Vec3(box2.position.x / OIMO_THREE.SCALE, box2.position.y / OIMO_THREE.SCALE, (box2.position.z + l / 2) / OIMO_THREE.SCALE);
        const worldAxis = new OIMO.Vec3(1, 0, 0);
        const c = new OIMO.RevoluteJointConfig();
        c.init(
          box2.oimo_rigid_body,
          box3.oimo_rigid_body,
          worldAnchor,
          worldAxis
        );
        c.limitMotor.setLimits(-90 * D2R, 90 * D2R)
        //c.limitMotor.setLimits(0 * D2R, 0 * D2R)
        //c.limitMotor.setLimits(-180 * Math.PI / 180, 180 * Math.PI / 180)
        //c.limitMotor.setMotor(-15 * Math.PI / 180, 5.0);
        //c.springDamper.setSpring(4, 1.0);
        const j = new OIMO.RevoluteJoint(c);
        oimo_world.addJoint(j);
      }
    }

    if("weight-scale"){
      const x = -300;
      const y = 30;
      const z = 0;

      const box1 = new THREE.Mesh(new THREE.BoxGeometry(100, 5, 100), whiteMaterial);
      box1.oimo_shape_config = {
        //density: 1/1000/1000/1000, // Kg/m^3
        //restitution: 1,
      }
      box1.position.set(x, y+20, z);
      OIMO_THREE.buildRigidBody(box1);
      scene.add(box1);
      oimo_world.addRigidBody(box1.oimo_rigid_body);

      const box2 = new THREE.Mesh(new THREE.BoxGeometry(100, 10, 100), grayMaterial);
      box2.oimo_rigid_body_config = {
        //type: OIMO.RigidBodyType.STATIC
      }
      box2.position.set(x, y, z);
      OIMO_THREE.buildRigidBody(box2);
      scene.add(box2);
      oimo_world.addRigidBody(box2.oimo_rigid_body);

      for(let i=0; i<100; i++){
        const box3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), redMaterial);
        const xx = (Math.random()*2-1)*20;
        const yy = (Math.random()*2-1)*20;
        const zz = (Math.random()*2-1)*20;
        box3.position.set(x+xx, y+100+yy, z+zz);
        OIMO_THREE.buildRigidBody(box3);
        scene.add(box3);
        oimo_world.addRigidBody(box3.oimo_rigid_body);
      }

      const worldAnchor = new OIMO.Vec3(box1.position.x / OIMO_THREE.SCALE, box1.position.y / OIMO_THREE.SCALE, box1.position.z / OIMO_THREE.SCALE);
      const worldAxis = new OIMO.Vec3(0, -1, 0);
      const c = new OIMO.PrismaticJointConfig()
      c.init(box1.oimo_rigid_body, box2.oimo_rigid_body, worldAnchor, worldAxis);
      const frequency    =  1000;
      const dampingRatio =  1000;
      c.springDamper.setSpring(frequency, dampingRatio);
      c.limitMotor.setLimits(0, 0);
      const j = new OIMO.PrismaticJoint(c);
      oimo_world.addJoint(j);

      let n = 0;
      box1.animate = ()=>{
        const g = oimo_world.getGravity().y;
        const f1 = box1.oimo_rigid_body.getMass() * g;
        const f = j.getAppliedForce().y;
        const precision = 100;
        console.log("n=", n, "m=", Math.round(precision*(f+f1)/(-g)*1000*1000*1000)/precision);
        n++;
      }
    }
  }
}

</script>
